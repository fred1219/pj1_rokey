# Auto Weld: ROS2 기반 용접 협동 로봇 자동화 시스템

**ROS 2 기반으로, 두산 협동로봇(M0609)을 활용하여 근로자와 협력할 수 있도록 설계되어, 작업 환경에서 안전하게 상호작용하며 인간의 업무를 보조해주는 역할을 구현하고자 했습니다.**
**2D/3D 용접 자동화 및 충돌 감지 안전 기능을 구현한 ROS2 기반 협동로봇 시스템을 구축했습니다.**

- 📅 **개발 기간**: 2025.05.14 ~ 05.21 (8일)
- 🧑‍🤝‍🧑 **인원 구성**: 4명  
  **(본인 역할: 3D 용접 자동화 시스템 설계, ROS 노드 연동 및 통합 테스트)**
- 🛠 **사용 기술**: ROS 2, Doosan dsr 패키지
- ✅ **주요 기능**: 2D/3D 용접 자동화, 예외 처리 및 안전 정지
- 
### 🎥 시연 영상

[![시연 영상 보기](https://img.youtube.com/vi/wykA4MYREYk/0.jpg)](https://youtu.be/wykA4MYREYk)

📄 [PDF 소개 자료](링크)  
💻 [GitHub 소스코드](링크)

## 📑 프로젝트 개요

- **주제**: Auto Weld (용접 협동 보조 로봇)
- **목표**: 2D/3D 용접 자동화 및 충돌 감지 안전 기능을 구현
- **팀원**: 4명

**🧑‍🤝‍🧑 팀원 역할 분담**
>|이름       |	역할      |
>|-----------|------------|
>|**이세현(작성자)**|	**규칙적 3D 용접 시스템 구현 및 원호 계산**|
>|이하빈|	불규칙적 2D 용접 경로 추출 및 좌표 변환|
>|홍진규|	Force 센서 기반 안전 기능 및 정지 제어|
>|최정호(팀장)|	규칙적 2D 용접 경로 구현|

프로젝트는 팀원 전체의 협업을 바탕으로 진행되었으며, 핵심 기능은 역할에 따라 분담하여 개발
<br>

**📅 작업 일정**
>| 기간 | 작업 내용 |
>|------|-----------|
>| 5/14 ~ 5/15 | 기획 및 주제 선정 |
>| 5/15 ~ 5/16 | 자료조사 및 레퍼런스 분석 |
>| 5/17 ~ 5/18 | 기능별 코드 개발 |
>| 5/19 ~ 5/20 | 중간 점검 및 통합 |
>| 5/20 ~ 5/21 | 최종 테스트 및 시연 준비 |
>| 총 개발 기간 | 8일 (5/14 ~ 5/21) |

---

## 1. 개발 배경 및 기획


### 🔧 핵심 기능

-  **규칙적 2D 용접**: 시작점과 도착점을 교시하여 직선 이동  
-  **불규칙 2D 용접**: 이미지 기반 경로 추출 → 좌표 스케일링 → CSV 기반 자동 이동  
-  **규칙적 3D 용접**: 3점 캡처 → 원 중심/반지름 계산 → movec 활용 경로 이동  
-  **충돌 감지 기능**: force 센서 값을 기반으로 경고음, 팝업, 로봇 정지 동작 실행

### 전체 요약

| 코드명            | 주요 기능 및 역할                                                                 | 특징                            |
| -------------- | -------------------------------------------------------------------------- | ----------------------------- |
| a\_home.py     | 직접교시 활성화 및 용접 포인트 3점 좌표 기록, <BR>원호 중심 및 반지름 계산, 원호 용접 경로 생성, 홈 위치 이동                             | 수학적 경로 계산 및 경로 계획             |
| movec.py       | 3점을 기반으로 계산한 원호 경로 용접 실행                                     | 규칙적 3D 원호 경로 제어               |
| 2d\_safe.py    | GUI → 이미지 선택 → 경로 추출 및 좌표 스케일 변환 →<br> CSV 저장 및 시각화 → CSV 기반 좌표 용접 실행 → 충격 감지 및 안전 정지 | 불규칙 2D 경로 용접 + 충격 감지 안전 기능 포함 |
| 2d\_ui.py      | UI노드(tkinter GUI) 구현, 직접 교시 활성화 및 시작점, 도착점 퍼블리시  | 사용자 인터페이스 제공, 경로 준비 보조        |
| 2d\_control.py | ROS2 토픽으로 좌표 수신, 선형이동 시작   | ROS2 통신 기반 좌표 수신 및 이동 제어   |

---

## 2. 사용 장비 & 기술 스택
<img width="800" height="400" alt="image" src="https://github.com/user-attachments/assets/b73eb584-f6cc-4057-812d-52271783d33b" />

## 3. 주요 기능 구현 과정

### 🟦 3-1. 규칙적 2D 용접

> 좌표 캡처 UI와 제어 노드를 분리 구성한 형태<br>
> <img width="400" height="200" alt="image" src="https://github.com/user-attachments/assets/304a309f-e44a-42e1-b36a-5af3ed19ce69" /> <br>
> **사용 코드:** `ui_node.py`, `control_node.py`

#### 🔹 `ui_node.py`

* **역할:**
  직접교시 모드 활성화로 사용자가 GUI를 통해 시작점, 도착점 좌표 기록 및 제어노드로 퍼블리시

---

#### 🔹 `control_node.py`

* **역할:**
  `ui_node`로부터 받은 포인트(좌표)를 바탕으로 선형이동 시작

---

### 🟥 3-2. 불규칙적 2D 용접

> 경로 이미지를 업로드하여, 지정한 간격으로 용접로봇이 이동할 포인트 추출 및 작동범위 고려 스케일링을 하여 스케일링된 좌표들을 csv파일에 저장하고 해당 좌표를 순차적으로 읽어 경로 이동<br>
> <img width="400" height="600" alt="image" src="https://github.com/user-attachments/assets/5f763a28-536c-447d-aa40-e9c9739fc33d" /> <br>
> **사용 코드:** `2d_safe.py`

#### 🔹 `2d_safe.py`

* **역할:**
  1. 경로 이미지 업로드를 통한 경로 포인트 추출
  2. 용접로봇의 작동범위를 고려하여 좌표 스케일링
  3. 스케일링된 좌표들을 csv 파일로 저장
  4. csv 파일을 순차적으로 읽어 경로 이동<br>

<br>
※ 따로 구현한 안전기능 코드를 통합하여 충돌감지 시 경고음, 팝업, 로봇 정지 동작 실행되도록 안전기능 구현
<img width="400" height="400" alt="image" src="https://github.com/user-attachments/assets/54834a2d-ca46-43ff-b36c-39e15d1a4565" /> <br>


---

### 🟩 3-3. 규칙적 3D 용접 (원호 용접)

> 포인트 3점 캡처 → 올바른 경로인지 계산 후 CSV 저장 → 파일 불러와 원호 경로 수행<br>
> <img width="400" height="400" alt="image" src="https://github.com/user-attachments/assets/6669ee51-c24c-4852-8a33-ed4802c37695" /> <br>
> **사용 코드:** `a_home.py`, `movec.py`

#### 🔹 `a_home.py`

* **역할:**

  * 작업 전 홈 위치로 이동
  * 사용자 조작으로 3개 좌표 캡처(**P1[도착점] → P2[경유] → P3[시작점]** 순)
  * `captured_robot_points.csv`에 저장
  * 중심점/반지름/평면 방향 계산하여 **movec 가능 여부 판단**

---

#### 🔹 `movec.py`

* **역할:**

  * `a_home.py`가 저장한 CSV 파일을 읽어
    **P3[시작점] → P2[경유] → P1[도착점]** 경로로 **원호 움직임 수행**<br>
(작업 사이클 타임 단축 목적으로 마지막 캡처 지점인 P3[시작점]에서 추가적인 이동없이 바로 용접이 수행 될 수있도록 구현) 
  * 실제 원호 용접 작업을 수행하는 메인 실행 코드
 
---

## 4. 핵심 코드 구현

### `2d_ui.py`

**역할**

* `/dsr01/msg/current_posx` 토픽을 구독하여 현재 로봇 TCP 좌표 수신
* GUI 버튼 클릭 시 현재 좌표를 `posx_2`, `posx_3`로 저장
* 저장된 두 좌표를 `/saved_posx_pair` 토픽으로 발행
* `/dsr01/system/set_robot_mode` 서비스로 로봇 모드 변경 요청
* Tkinter GUI와 ROS2 노드를 병렬로 실행하여 제어

**ROS2 구성**

* **노드명**:

  * 구독/발행: `PosTopicSubscriber`
  * 서비스 클라이언트: `service_client_node`
* **구독 토픽**:

  * `/dsr01/msg/current_posx` (`Float64MultiArray`)
* **발행 토픽**:

  * `/saved_posx_pair` (`Float64MultiArray`)
* **서비스 클라이언트**:

  * `/dsr01/system/set_robot_mode` (`dsr_msgs2/srv/SetRobotMode`)
* **기타**:

  * `rclpy.init()` 및 `rclpy.shutdown()` 사용
  * `rclpy.spin()`은 구독 노드에서만 별도 스레드로 실행

---

### `2d_control.py`

**역할**

* `/saved_posx_pair` 토픽에서 두 개의 posx 좌표 배열 수신
* 수신된 좌표를 순차적으로 `movej`, `movel` 명령으로 이동
* 이동 완료 후 초기 위치로 복귀
* 한 번의 데이터 수신 후 처리하고 대기

**ROS2 구성**

* **노드명**: `posx_mover` (namespace: `dsr01`)
* **구독 토픽**: `/saved_posx_pair` (`Float64MultiArray`)
* **발행 토픽**: 없음
* **서비스/액션**: 없음
* **기타**:

  * `rclpy.init()` 및 `rclpy.create_node()`로 노드 생성
  * `DR_init.__dsr__node`를 통해 DSR API 연동 후 명령 실행
  * `rclpy.spin_once()`로 데이터 수신 처리
  * 종료 시 `rclpy.shutdown()` 호출

---

### `2d_safe.py`

**역할**

* 사용자로부터 이미지를 입력받아 용접 경로 좌표를 추출 및 시각화
* 추출된 좌표를 CSV 파일로 저장하고 기록 유지
* 저장된 좌표를 불러와 로봇에 `movel` 명령으로 경로 이동 실행
* 이동 중 툴 힘 센서를 기반하여 충격 발생 시 경고음 및 팝업 표시

**ROS2 구성**

* **노드명**: `rokey_simple_move` (namespace: `dsr01`)
* **구독 토픽**: 없음 (툴 힘 센서 값, 현재 위치는 DSR API 함수 호출로 직접 획득)
* **발행 토픽**: 없음
* **서비스/액션**: 없음
* **기타**:

  * `rclpy.init()`, `rclpy.create_node()`로 노드 생성
  * `DR_init.__dsr__node`로 DSR API 연동 후 `movel` 명령 실행
  * ROS2 스핀 없이 단순 실행
  * 종료 시 `rclpy.shutdown()` 호출

---
### `a_home.py`

**역할**

* 로봇을 홈 위치로 `movej` 명령으로 이동
* TCP 좌표 3개를 캡처하여 저장
* 3개의 좌표로 원의 중심과 반지름 계산
* GUI에서 실시간 좌표 모니터링, 캡처, 계산, 저장 기능 제공
* 로봇 모드 변경 서비스 호출 기능 포함

**ROS2 구성**

* **노드명**: `welding_move` (namespace: `dsr01`)
* **구독 토픽**:

  * `/dsr01/msg/current_posx` (`Float64MultiArray`)
  * `/dsr01/msg/joint_state` (`Float64MultiArray`)
* **발행 토픽**: 없음
* **서비스 클라이언트**:

  * `/dsr01/system/set_robot_mode` (`dsr_msgs2/srv/SetRobotMode`)
* **기타**:

  * GUI와 ROS2를 함께 실행
  * 로컬 계산과 로봇 제어를 병행

---

### `movec.py`

**역할**

* CSV 파일에서 3개의 포인트(P1, P2, P3) 좌표 읽기
* P3으로 직선 이동(`movel`)
* P2 경유 후 P1로 원호 이동(`movec`)
* 툴과 TCP 설정 후 이동 명령 실행
* 예외 처리와 ROS2 노드 생성·종료 관리 포함

**ROS2 구성**

* **노드명**: `movec` (namespace: `dsr01`)
* **구독 토픽**: 없음 (좌표는 CSV에서 직접 읽음)
* **발행 토픽**: 없음
* **서비스/액션**: 없음
* **기타**:

  * `rclpy.init()` 및 `rclpy.create_node()`로 노드 생성
  * `DR_init.__dsr__node`로 DSR API 연동
  * 종료 시 `rclpy.shutdown()` 호출

---

## 5. 도전 과제와 문제 해결 방법

| 도전 과제                                | 문제 상황                                                                 | 해결 방법                                                   |
| ------------------------------------ | --------------------------------------------------------------------- | ------------------------------------------------------- |
| **다중 ROS 노드 실행 시 GUI 응답 불가**         | Tkinter GUI 실행과 ROS2 스핀을 한 프로세스에서 동시에 실행하려고 하니 GUI가 멈추거나 ROS2 콜백이 지연됨 | Python `threading` 모듈로 ROS2 구독 스레드와 GUI 메인 루프를 분리 실행    |
| **이미지 기반 좌표 추출 정확도 부족**              | 불규칙 2D 용접에서 이미지 해상도·스케일링에 따라 경로 오차 발생                                 | OpenCV에서 좌표 보정 및 스케일링 비율 고정, 테스트를 통해 최적 픽셀→로봇좌표 변환식 적용  |
| **3D 원호 계산 시 movec 불가능 판정 오류**       | 세 점이 거의 직선에 가까울 경우에도 movec 시도하여 에러 발생                                 | 세 점 간 벡터 내적·거리 기반으로 평면성 판정 후, 조건 불충족 시 경고 및 재촬영 요청      |
| **안전 기능 지연 반응**                      | Force 센서 값 폴링 주기가 길어 충격 반응이 늦음                                        | 센서 값 읽기를 별도 스레드로 실행하여 주기 10ms 이하로 단축, 실시간 정지 명령 구현      |
| **DSR API와 ROS2 토픽 혼용 시 데이터 동기화 문제** | API 호출값과 ROS2 토픽 값이 시점차로 달라 로봇 동작에 미세한 오차 발생                          | 중요한 실시간 제어는 DSR API 직접 호출, 모니터링·UI 데이터는 ROS2 토픽 기반으로 분리 |

---

## 6. 협업 내용 및 진행 과정

### 🤝 협업 내용
* Google Docs와 notion 통한 **공유 및 협업 개발**
* 기능별 코드 작성 후 **로컬 시뮬레이터 검증 → 실제 로봇 적용**
* ROS2 네임스페이스(`dsr01`) 규칙 통일
* CSV 데이터 포맷, 토픽명, 서비스명 표준화

### 📌 진행 과정
1. **기획 회의** – 주제 선정 및 2D/3D 기능 분리 설계
2. **기능별 개발** – 각자 맡은 기능 독립 개발
3. **중간 통합 테스트** – 각 기능 실행 순서·의존성 점검
4. **문제 수정 및 성능 개선** – 계산 정확도, 속도, 안전성 향상
5. **최종 시연 준비** – 발표 자료 제작 및 데모 시나리오 구성

---

## 7. 성과 및 결과물

* **ROS2 기반 다기능 협동로봇 제어 시스템 완성**
* **규칙적/불규칙적 2D·3D 용접** 기능 구현 및 실환경 테스트 통과
* **Force 센서 기반 안전정지** 적용 → 작업자 안전 확보
* **GUI 기반 교시 및 경로 설정**으로 비전문가도 용접 작업 경로 설정 가능


---

## 8. 프로젝트 결과

* **목표 달성도**: 90% 이상<br>
  (기능적인 부분은 대부분 구현하였으나, GUI와 쓰레드 기능 충돌로 인해 별도의 노드로 분리하여 구현하였음. 또한 안전 기능 통합 과정에서 기존 코드에 안전 기능 코드를 단순 추가하는 것이 아닌 별도 노드를 실행시켜 호환성을 높이고 싶었으나 지식 및 시간적문제로 기간내 구현을 하지 못하였던 것이 아쉬웠음)
* **팀 협업 완성도**: 4명 전원이 제 기능 개발 완료 및 통합 성공
* **적용 가능성**: 실제 산업 현장에서 간단한 용접 보조·반복 작업에 적용 가능
---

## 9. 개인적 성찰 및 배운 점

* ROS2의 **토픽·서비스·액션** 구조를 실제 로봇 시스템에 적용해보며 데이터 흐름 설계 역량 향상
* 3D 기하 계산(원호 중심·반지름, 평면 판정)과 로봇 좌표계 이해 심화
* 실환경 테스트의 중요성 인식 — 시뮬레이션에서는 드러나지 않는 물리적 제약과 센서 지연 문제 발견
* 협업 과정에서 **명세 통일**(토픽명, 파일 포맷, 네임스페이스)이 유지보수성을 크게 좌우함을 체감
* Force 센서를 활용한 안전정지 로직 구현 경험 축적

---

## 10. 개선 및 확장 아이디어

1. **다중 공정 지원**

   * 용접 외에 절단, 도색, 검수 등의 공정으로 확장
   * 툴 체인저와 연동


2. **협동로봇 기반 용접 후 품질 검사 (Machine Vision 적용)**

   * 딥러닝 기반 결함 판단 모델 적용
   * 비전 소프트웨어 (OpenCV + AI 모델)
   * 판정 기준 알고리즘 (길이, 너비, 비드 일관성 등) 적용
